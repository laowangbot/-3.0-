# 媒体组编号显示问题修复进度

## 问题描述

### 现象
在评论区搬运过程中，当媒体组被拆分时，日志显示的编号会出现重复或错误：
- 原始队列：37个项目（36个媒体组 + 1个单条媒体组）
- 当第34个媒体组（包含14个媒体）被拆分时，它被拆分成2个组
- 实际应该处理：38个项目（37 - 1 + 2 = 38）
- 但日志显示的编号仍然是 `[33/37]` 和 `[34/37]`，这里的"37"是原始队列总数

### 根本原因
日志编号显示使用了固定的 `len(processing_queue)`（原始队列长度），而不是实际处理的队列长度。
当媒体组被拆分时，新的组被添加到 `send_queue`，但日志显示的编号没有更新。

### 影响
- **功能影响**：无，所有媒体组都被正确发送了（从日志可以看到所有37个组都被发送了，包括拆分后的2个组）
- **用户体验**：日志显示混乱，用户可能误解为有重复处理或编号错误

## 已完成的修改

### 1. 添加动态总数跟踪变量
**位置**：`cloning_engine.py` - `_download_media_groups_pipeline` 方法
**修改内容**：
```python
# 动态跟踪实际总数（包括拆分后的媒体组）
actual_total_count = len(processing_queue)
```

### 2. 修改循环条件
**位置**：`cloning_engine.py` - `_download_media_groups_pipeline` 方法（第3368行）
**修改内容**：
```python
# 从 while True: 改为
while queue_index < len(processing_queue):
```

## 已完成的修改（续）

### 4. 更新拆分完成后的总数 ✅
**位置**：`cloning_engine.py` - 媒体组拆分完成后（第3474-3476行）
**修改内容**：
```python
# 拆分后，1个组变成了多个组，需要更新总数
# 如果原始有1个组，拆分成N个组，则总数增加 (N-1)
actual_total_count += (len(split_groups) - 1)
```

### 5. 在 DownloadedMediaGroup 中添加 total_count 字段 ✅
**位置**：`cloning_engine.py` - `DownloadedMediaGroup` 类定义（第179-187行）
**修改内容**：
```python
@dataclass
class DownloadedMediaGroup:
    """已下载的媒体组数据"""
    group_id: Any
    group_comments: List[Message]
    media_list: List[Any]
    downloaded_files: List[str]
    queue_index: int
    total_count: int = 0  # 动态总数（包括拆分后的媒体组）
```

### 6. 修改构建时的编号显示逻辑 ✅
**位置**：`cloning_engine.py` - 显示构建媒体组编号的地方（第3400行）
**修改内容**：
```python
# 从 len(processing_queue) 改为 actual_total_count
logger.info(f"[构建] 📦 [{group_idx + 1}/{actual_total_count}] 构建媒体组 (ID: {str(group_id)[:8] if group_id else 'N/A'}...)")
```

### 7. 在创建 DownloadedMediaGroup 时传递 total_count ✅
**位置**：`cloning_engine.py` - 拆分和未拆分的媒体组创建（第3463-3492行）
**修改内容**：
- 拆分媒体组：在创建时传递 `total_count=actual_total_count + (num_splits - 1)`，并在放入队列前更新为最新值
- 未拆分媒体组：传递 `total_count=actual_total_count`

### 8. 修改发送时的编号显示逻辑 ✅
**位置**：`cloning_engine.py` - `_send_media_groups_pipeline` 方法（第3532-3576行）
**修改内容**：
- 添加发送计数器 `send_index`，用于显示连续编号
- 修改显示逻辑，优先使用 `total_count`，否则只显示索引：
  ```python
  # 显示编号，优先使用 total_count，否则使用发送计数器
  if downloaded_group.total_count > 0:
      logger.info(f"[发送] 📦 [{send_index}/{downloaded_group.total_count}] 发送媒体组 ...")
  else:
      logger.info(f"[发送] 📦 [{send_index}] 发送媒体组 ...")
  ```

## 修复完成状态

✅ **所有计划中的修改已完成！**

### 修复效果
- ✅ 动态跟踪实际总数（包括拆分后的媒体组）
- ✅ 构建时显示正确的编号和总数
- ✅ 发送时显示正确的编号和总数
- ✅ 拆分后总数自动更新

### 说明
- 队列总数显示（第3995行）仍显示原始总数，这是合理的，因为此时还未开始处理，无法预知拆分情况
- 实际处理过程中，编号会动态更新，显示正确的总数

## 相关代码位置

### 关键方法
- `_download_media_groups_pipeline`: 约第3365行
- `_clone_message_comments`: 约第3640行

### 关键变量
- `queue_index`: 当前处理的队列索引
- `processing_queue`: 原始处理队列
- `actual_total_count`: 动态跟踪的实际总数（新增）
- `split_groups_count`: 拆分组计数（新增，但还未使用）

### 关键代码段
1. **媒体组拆分逻辑**：约第3449-3500行
   - `MAX_MEDIA_PER_GROUP = 10`
   - `if len(media_list) > MAX_MEDIA_PER_GROUP:`
   - 拆分逻辑和放入队列

2. **编号显示逻辑**：需要找到显示 `📦 [X/Y] 构建媒体组` 的代码

3. **队列总数显示**：需要找到显示 `📋 处理队列已创建并排序` 的代码（约第4000行附近）

## 测试建议

修复完成后，建议测试以下场景：
1. 正常媒体组（不拆分）
2. 单个媒体组需要拆分（超过10个媒体）
3. 多个媒体组需要拆分
4. 混合场景（有拆分和未拆分的媒体组）

## 备注

- 这是一个日志显示问题，不影响实际功能
- 所有媒体组都会被正确发送，只是日志编号显示不准确
- 修复后，日志会显示正确的编号，提高可读性

## 修复完成日期

**2024年修复完成** ✅

## 修复总结

所有计划中的修改已完成，媒体组编号显示问题已修复。现在：
- 当媒体组被拆分时，总数会动态更新
- 构建和发送日志都会显示正确的编号和总数
- 用户体验得到改善，日志更加清晰准确

## 后续测试建议

修复完成后，建议测试以下场景：
1. ✅ 正常媒体组（不拆分）
2. ✅ 单个媒体组需要拆分（超过10个媒体）
3. ✅ 多个媒体组需要拆分
4. ✅ 混合场景（有拆分和未拆分的媒体组）
