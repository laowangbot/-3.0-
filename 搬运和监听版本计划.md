# 搬运和监听版本计划

## 📋 项目概述

完全重构机器人流程，放弃频道组模式，改为基于管理员频道的管理模式，并增加实时监听功能。

## 🎯 核心功能设计

### 1. 新流程架构

**完全放弃频道组流程**
- 不再使用频道组配对模式
- 改为"我的频道"管理模式
- 每个频道独立配置和搬运

**新的数据存储结构**
```python
用户配置:
├── admin_channels: [频道列表]
│   ├── channel_id: -1001234567890
│   ├── channel_name: "我的频道1"
│   ├── channel_type: "public/private"
│   ├── admin_since: "2025-01-02 20:30:00"
│   └── filter_config: {过滤配置}
└── cloning_sessions: [搬运会话]
    ├── session_id: "session_123"
    ├── target_channel: -1001234567890
    ├── source_channels: [
    │   ├── {channel_id: -1001111111111, message_range: "100-200"}
    │   └── {channel_id: -1002222222222, message_range: "300-400"}
    │   ]
    └── status: "pending/running/completed"
```

### 2. 监听功能

**监听任务结构**
```python
class MonitoringTask:
    session_id: str
    user_id: str
    target_channel: str
    source_channels: List[Dict]  # 每个源频道的最后消息ID
    monitoring_interval: int = 60  # 秒
    is_active: bool = True
    last_check_time: datetime
    next_check_time: datetime
```

**监听数据存储**
```python
monitoring_tasks: {
    "user_123": {
        "task_456": {
            "target_channel": "-1001234567890",
            "source_channels": [
                {
                    "channel_id": "-1001111111111",
                    "channel_username": "@source1",
                    "last_message_id": 1500,
                    "check_interval": 60,
                    "next_check": "2025-01-02 20:35:00"
                },
                {
                    "channel_id": "-1002222222222", 
                    "channel_username": "@source2",
                    "last_message_id": 2300,
                    "check_interval": 120,  # 错开时间
                    "next_check": "2025-01-02 20:36:00"
                }
            ],
            "status": "active"
        }
    }
}
```

## 🔧 技术实现方案

### 1. 数据层改造

**新的数据管理方法**
```python
class LocalDataManager:
    async def get_admin_channels(self, user_id: str) -> List[Dict]
    async def update_channel_filter_config(self, user_id: str, channel_id: str, config: Dict)
    async def create_cloning_session(self, user_id: str, session_data: Dict)
    async def get_cloning_sessions(self, user_id: str) -> List[Dict]
    async def create_monitoring_task(self, user_id: str, task_data: Dict)
    async def get_monitoring_tasks(self, user_id: str) -> List[Dict]
    async def update_monitoring_task(self, user_id: str, task_id: str, updates: Dict)
```

### 2. 监听引擎

**核心监听引擎**
```python
class MonitoringEngine:
    async def start_monitoring(self, task: MonitoringTask)
    async def check_channel_updates(self, channel_info: Dict) -> List[Message]
    async def process_new_messages(self, messages: List[Message], target_channel: str)
    async def update_last_message_id(self, channel_id: str, message_id: int)
    async def schedule_next_check(self, task: MonitoringTask)
    async def stop_monitoring(self, task_id: str)
    async def pause_monitoring(self, task_id: str)
    async def resume_monitoring(self, task_id: str)
```

**API限制处理**
```python
class APIRateLimiter:
    def __init__(self):
        self.last_request_time = {}
        self.min_interval = 1  # 最小间隔1秒
    
    async def wait_if_needed(self, channel_id: str):
        if channel_id in self.last_request_time:
            elapsed = time.time() - self.last_request_time[channel_id]
            if elapsed < self.min_interval:
                await asyncio.sleep(self.min_interval - elapsed)
        self.last_request_time[channel_id] = time.time()
```

**时间错开策略**
```python
def calculate_check_intervals(channels: List[str]) -> Dict[str, int]:
    base_interval = 60  # 基础间隔60秒
    intervals = {}
    for i, channel in enumerate(channels):
        intervals[channel] = base_interval + (i * 10)  # 每个频道错开10秒
    return intervals
```

### 3. 权限检测

**管理员频道检测**
```python
async def _detect_admin_channels(self, user_id: str) -> List[Dict]
async def _check_channel_admin_status(self, channel_id: str) -> bool
async def _get_channel_permissions(self, channel_id: str) -> Dict
async def _update_admin_channels_list(self, user_id: str)
```

## 🎮 用户界面流程

### 1. 新的UI流程

**主菜单结构**
```
主菜单
├── 📡 我的频道 (显示管理员频道列表)
│   ├── 频道1 [配置] [搬运] [监听]
│   ├── 频道2 [配置] [搬运] [监听]
│   └── 频道3 [配置] [搬运] [监听]
├── ⚙️ 全局设置
├── 📊 任务状态
└── 🔍 监听管理
```

**搬运流程**
```
选择目标频道 → 输入源频道+ID段 → 添加更多源 → 开始搬运
```

**监听设置流程**
```
选择目标频道 → 设置监听 → 输入源频道 → 输入最后消息ID → 确认设置
```

### 2. 监听管理界面

**监听任务管理**
```
📡 监听任务管理

✅ 任务1: 我的频道1
   📡 监听: @source1 (最后ID: 1500)
   📡 监听: @source2 (最后ID: 2300)
   ⏰ 下次检查: 20:35:00
   [暂停] [编辑] [删除]

✅ 任务2: 我的频道2
   📡 监听: @source3 (最后ID: 800)
   ⏰ 下次检查: 20:36:00
   [暂停] [编辑] [删除]
```

## ⚡ 高级功能

### 1. 智能监听

**智能检查频率**
```python
def calculate_optimal_interval(self, channel_activity: Dict) -> int:
    # 根据频道活跃度调整检查频率
    if channel_activity.get('high_activity', False):
        return 30  # 高活跃频道30秒检查一次
    elif channel_activity.get('medium_activity', False):
        return 60  # 中等活跃频道60秒检查一次
    else:
        return 120  # 低活跃频道120秒检查一次
```

**消息获取策略**
```python
async def get_new_messages(self, channel_id: str, last_message_id: int) -> List[Message]:
    try:
        # 获取频道最新消息
        messages = await self.client.get_messages(
            entity=channel_id,
            limit=100,  # 每次最多获取100条
            min_id=last_message_id
        )
        return messages
    except Exception as e:
        logger.error(f"获取频道消息失败: {e}")
        return []
```

### 2. 错误处理与重试

**健壮的频道检查**
```python
async def robust_channel_check(self, channel_info: Dict, max_retries: int = 3):
    for attempt in range(max_retries):
        try:
            return await self.check_channel_updates(channel_info)
        except FloodWaitError as e:
            logger.warning(f"API限制，等待{e.value}秒")
            await asyncio.sleep(e.value)
        except Exception as e:
            logger.error(f"检查频道失败 (尝试{attempt+1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                await asyncio.sleep(5 * (attempt + 1))  # 指数退避
    return []
```

### 3. 批量处理

**多消息批量搬运**
- 多个新消息批量搬运
- 保持消息的时间顺序
- 避免重复搬运

## 📊 实施计划

### 阶段1：数据层改造
- [ ] 修改数据存储结构
- [ ] 实现新的数据管理方法
- [ ] 数据迁移脚本
- [ ] 测试数据层功能

### 阶段2：权限检测
- [ ] 实现管理员频道检测
- [ ] 权限状态监控
- [ ] 自动更新机制
- [ ] 权限验证功能

### 阶段3：UI重构
- [ ] 新的频道管理界面
- [ ] 多源频道输入流程
- [ ] 搬运会话管理
- [ ] 监听任务管理界面

### 阶段4：监听引擎
- [ ] 实现监听引擎核心
- [ ] API限制处理
- [ ] 智能频率调整
- [ ] 错误处理与重试

### 阶段5：搬运引擎适配
- [ ] 适配新的数据格式
- [ ] 多源频道处理逻辑
- [ ] 会话状态管理
- [ ] 性能优化

### 阶段6：测试与优化
- [ ] 功能测试
- [ ] 性能测试
- [ ] 错误处理测试
- [ ] 用户体验优化

## 🎯 预期效果

### 用户体验提升
- **操作更直观**: 直接看到自己的频道，无需复杂的频道组配置
- **配置更灵活**: 每个频道独立配置，支持不同的过滤规则
- **管理更简单**: 自动检测管理员状态，减少手动配置
- **自动化程度更高**: 实时监听功能，无需手动触发搬运

### 功能增强
- **多源频道支持**: 一次可以输入多个源频道，每个设置不同的消息ID段
- **实时监听功能**: 自动发现新消息并搬运，支持公共频道监听
- **智能权限检测**: 实时检测机器人管理员状态
- **自动错误恢复**: 智能重试机制，自动处理各种错误情况

### 维护简化
- **自动状态同步**: 监听任务状态自动更新
- **减少手动操作**: 智能配置管理，自动优化检查频率
- **智能配置管理**: 根据频道活跃度自动调整参数
- **完善的监控机制**: 详细的统计信息和错误日志

## ⚠️ 注意事项

### API限制
- Telegram API有严格的频率限制
- 需要合理分配检查时间
- 实现智能退避策略

### 资源消耗
- 长时间运行的内存占用
- 网络连接管理
- 数据库查询优化

### 错误恢复
- 机器人重启后的任务恢复
- 网络中断的自动重连
- 数据一致性保证

### 隐私考虑
- 只显示机器人自己的权限
- 不显示其他管理员信息
- 保护用户隐私数据

## 📈 扩展功能

### 1. 权限检查
- 检查特定频道的管理员权限
- 对比不同频道的权限差异
- 权限不足时提醒用户

### 2. 自动修复
- 提供权限问题的解决建议
- 自动检测和修复配置问题
- 智能错误诊断

### 3. 监控统计
- 监听任务执行统计
- 新消息发现统计
- 搬运成功率统计
- 性能指标监控

### 4. 高级配置
- 自定义监听频率
- 智能过滤规则
- 批量操作支持
- 任务模板功能

---

**创建时间**: 2025-01-02  
**版本**: v2.0  
**状态**: 计划阶段  
**优先级**: 高
